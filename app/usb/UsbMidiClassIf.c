/**
******************************************************************************
* @file    UsbMidiClass.h
* @author  apaluch
* @brief   This file is reworked version of usbd_cdc_if.c file generated by stm32cube for CDC USB calss.
******************************************************************************
*
* This software component is licensed by ST under Ultimate Liberty license
* SLA0044, the "License"; You may not use this file except in compliance with
* the License. You may obtain a copy of the License at:
*                      www.st.com/SLA0044
*
******************************************************************************
*/

#include <stdio.h>
#include <usb/UsbMidiClassIf.h>

extern void newUsbMidiData(uint8_t* buf, uint32_t len);

/** Received data over USB are stored in this buffer      */
uint8_t MidiRxBufferFS[APP_RX_DATA_SIZE];

/** Data to send over USB MIDI are stored in this buffer   */
uint8_t MidiTxBufferFS[APP_TX_DATA_SIZE];

extern USBD_HandleTypeDef hUsbDeviceFS;

static int8_t UsbMidiClass_Init_FS(void);
static int8_t UsbMidiClass_DeInit_FS(void);
static int8_t UsbMidiClass_Control_FS(uint8_t cmd, uint8_t* pbuf, uint16_t length);
static int8_t UsbMidiClass_Receive_FS(uint8_t* pbuf, uint32_t *Len);

UsbMidiClass_ItfTypeDef UsbMidiClass_Interface_fops_FS =
{
  UsbMidiClass_Init_FS,
  UsbMidiClass_DeInit_FS,
  UsbMidiClass_Control_FS,
  UsbMidiClass_Receive_FS
};

/**
  * @brief  Initializes the MIDI media low layer over the FS USB IP
  * @retval USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t UsbMidiClass_Init_FS(void)
{
  /* Set Application Buffers */
  UsbMidiClass_SetTxBuffer(&hUsbDeviceFS, MidiTxBufferFS, 0);
  UsbMidiClass_SetRxBuffer(&hUsbDeviceFS, MidiRxBufferFS);

  return (USBD_OK);
}

/**
  * @brief  DeInitializes the MIDI media low layer
  * @retval USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t UsbMidiClass_DeInit_FS(void)
{
  return (USBD_OK);
}

/**
  * @brief  Manage the MIDI class requests
  * @param  cmd: Command code
  * @param  pbuf: Buffer containing command data (request parameters)
  * @param  length: Number of data to be sent (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t UsbMidiClass_Control_FS(uint8_t cmd, uint8_t* pbuf, uint16_t length)
{
  switch(cmd)
  {
  default:
    break;
  }

  return (USBD_OK);
}

/**
  * @brief  Data received over USB OUT endpoint are sent over MIDI interface
  *         through this function.
  *
  *         @note
  *         This function will issue a NAK packet on any OUT packet received on
  *         USB endpoint until exiting this function. If you exit this function
  *         before transfer is complete on MIDI interface (ie. using DMA controller)
  *         it will result in receiving more data while previous ones are still
  *         not sent.
  *
  * @param  Buf: Buffer of data to be received
  * @param  Len: Number of data received (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t UsbMidiClass_Receive_FS(uint8_t* Buf, uint32_t *Len)
{
  newUsbMidiData(Buf, *Len);

  UsbMidiClass_SetRxBuffer(&hUsbDeviceFS, &Buf[0]);
  UsbMidiClass_ReceivePacket(&hUsbDeviceFS);

  return (USBD_OK);
}

/**
  * @brief  MIDI_Transmit_FS
  *         Data to send over USB IN endpoint are sent over MIDI interface
  *         through this function.
  *         @note
  *
  *
  * @param  Buf: Buffer of data to be sent
  * @param  Len: Number of data to be sent (in bytes)
  * @retval USBD_OK if all operations are OK else USBD_FAIL or USBD_BUSY
  */
uint8_t MIDI_Transmit_FS(uint8_t* Buf, uint16_t Len)
{
  uint8_t result = USBD_OK;

  UsbMidiClass_HandleTypeDef *hmidi = (UsbMidiClass_HandleTypeDef*)hUsbDeviceFS.pClassData;
  if (hmidi->TxState != 0){
    return USBD_BUSY;
  }
  UsbMidiClass_SetTxBuffer(&hUsbDeviceFS, Buf, Len);
  result = UsbMidiClass_TransmitPacket(&hUsbDeviceFS);

  return result;
}
